# 设计模式
## 设计模式原则
单一职责：一个类和方法只做一件事
里氏替换：多态、子类可扩展父类
依赖倒置：细节依赖抽象，下层依赖上层
接口隔离：建立单一接口
迪米特原则：最少知道，降低耦合
开闭原则：抽象架构，扩展实现

## 设计模式空间
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13D1D461-9660-40D4-882D-4EB19633CE95.png)
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0F04EFF8-7C0A-41C5-B6AC-E2BF3A738E0E.png)
设计模式之间的关系：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2EA37FF4-93D3-454F-822B-6C7D8820A9D2.png)
设计模式所支持的设计的可变方面：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/39DB1EB8-C421-491E-B6BE-A7B86E20E479.png)


## 创建型模式
创建型模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。

### Abstract Factory(抽象工厂)-对象创建型模式
#### 作用：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
#### 适应性：
* 一个系统要独立于它的产品的创建、组合和表示时；
* 一个系统要由多个产品系列中的一个来配置时；
* 当你要强调一系列相关的产品对象的设计以便进行联合使用时；
* 当你提供一个产品类库，而只想显示它们的接口而不是实现时。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/122A3722-AA80-4AB1-A279-3C00FCE4C3DD.png)
#### 相关模式：
AbstractFactory类通常用工厂方法(Factory Method)实现，但它们也可以用Prototype实现；
一个具体的工厂通常是一个单件(Singleton)

### Builder(生成器)-对象创建型模式
#### 作用：
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
#### 适用性：
* 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；
* 当构造过程必须允许被构造的对象有不同的表示时。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8F7B9990-EB78-4078-803A-25612091DD8B.png)
#### 协作：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9A211E9E-C01A-4138-86A8-C9D3A687D1E5.png)


### Factory Method(工厂方法)-对象创建型模式
#### 作用：
定义一个用于创建对象的接口，让其子类自己决定实例化哪一个类，使一个类的实例化延迟到其子类。
#### 适用性：
* 当一个类不知道它所必须创建的对象的类的时候；
* 当一个类希望由它的子类来指定它所创建的对象的时候；
* 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类时代理者这一信息局部化的时候。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9BAB1379-ECE2-4BA9-960B-BA5B22A29ADA.png)
#### 相关模式：
工厂方法通常在Template Method中被调用。

### Prototype(原型)-对象创建型模式
#### 作用：
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
#### 适用性：
* 当一个系统应该独立于它的产品创建、构成和表示时；
* 当要实例化的类是在运行时刻指定时（比如动态加载）；
* 为了避免创建一个与产品类层次平行的工厂类层次时；
* 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9B178BA6-00C5-4BC9-8204-5C20CD9D45F2.png)

### Singleton(单件)-对象创建型模式
#### 作用：
保证一个类仅有一个实例，并提供一个访问它的全局访问点。
#### 适用性：
* 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；
* 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码即能使用一个扩展的实例时。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5055D9C2-490B-4DB1-B985-275ECDF4B166.png)



## 结构型模式
结构型模式涉及到如何组合类和对象以获得更大的结构。
结构型类模式采用继承机制来组合接口或实现。
结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。（可在运行时刻改变对象组合关系）

### Adapter（适配器）-类对象结构型模式
#### 作用：
把原本不兼容的接口，通过适配修改做到统一。
Adapter时常还需要负责提供那些被匹配的类所没有提供的功能。
#### 适用性：
* 想使用一个已经存在的类，而它的接口不符合你的要求
* 想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作
* （仅适用于对象Adapter）想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。
#### 结构
类适配器使用多重继承对一个接口与另一个接口进行匹配：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/FF5ECF29-34E3-4087-9FF2-751A60F049B5.png)
（类适配器的关键是用一个分支继承接口，而用另外一个分支继承接口的实现部分。C++：用公共方式继承接口，用私有方式继承接口的实现。）
对象适配器依赖于对象组合：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/C7A5AAC9-D0A6-4BB0-91AD-E4B1FE1BB319.png)

### Bridge（桥接）-对象结构型模式
#### 作用：
将抽象部分与它的实现部分分离，使它们都可以独立地变化。
#### 适用性：
* 你不希望在抽象和它的实现部分之间有一个固定的绑定关系；
* 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充；
* 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译；
* （C++）你想对客户完全隐藏抽象的实现部分
* 有许多类要生成
* 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2A390C19-5836-4C93-88D4-CADFB452B6A2.png)

### Composite(组合)-对象结构型模式
#### 作用：
将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。
#### 适用性：
* 你想表示对象的部分-整体层次结构；
* 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3F3EEFE7-B959-46DB-889B-BB0580740BA0.png)
典型的Composite对象结构如下图：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0C8393BF-3B1D-42B3-B9C4-D37B58555990.png)
#### 相关模式：
通常部件-父部件连接用于Responsibility of Chain模式；
Decorator模式经常与Composite模式一起使用，它们通常有一个公共的父类；
Flyweight让你共享组件，但不再能引用它们的父部件；
Iterator可用来遍历Composite；
Visitor将本来应该分布在Composite和Leaf类中的操作和行为局部化。

### Decorator(装饰)-对象结构型模式
#### 作用：
动态地给一个对象添加一些额外的职责。
#### 适用性：
* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；
* 处理那些可以撤销的职责；
* 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况是因为类定义被隐藏，或类定义不能用于生成子类。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7E28967D-FB0B-4537-B7CE-712EEC4F5DA8.png)

### Facade(外观)-对象结构型模式
#### 作用：
为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
#### 适用性：
* 当你要为一个复杂子系统提供一个简单接口时；
* 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他的子系统分离，提供子系统的独立性和可移植性；
* 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09B9FCD9-E3FB-4192-A5AF-234C949D8901.png)

### Flyweight(享元)-对象结构型模式
#### 作用：
运用共享技术有效地支持大量细粒度的对象。
#### 适用性：
* 一个应用程序使用了大量的对象；
* 完全由于使用大量的对象，造成很大的存储开销；
* 对象的大多数状态都可变为外部状态；
* 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象；
* 应用程序不依赖于对象标识。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8615D3C1-9F6C-4113-9F5B-D135DBBA8926.png)
下面的对象图说明如何共享flyweight：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4EFE9217-E2DF-47C7-A2A4-8EF12108C7CC.png)
#### 相关模式
Flyweight模式通常和Composite模式结合起来，用共享叶节点的有向无环图实现一个逻辑上的层次结构；
通常，最好用Flyweight实现State和Strategy对象。

### Proxy(代理)-对象结构型模式
#### 作用：
为其他对象提供一种代理以控制对这个对象的访问。
#### 适用性：
在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。
下面是一些常见情况：
* 远程代理：为一个对象在不同的地址空间提供局部代表；
* 虚代理：根据需要创建开销很大的对象；
* 保护代理：控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。
* 智能指引：取代了简单的指针，它在访问对象时执行一些附加操作
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5CAA731C-DFBE-4C9D-8291-0E0DA768511D.png)
下图为运行时刻一种可能的代理结构的对象图：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23805A32-E270-441B-8AED-F2B4E89A0F08.png)

## 行为模式
行为模式涉及到算法和对象间职责的分配。
行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻画了在运行时难以跟踪的复杂的控制流，将你的注意力从控制流转移到对象间的联系方式上来。
行为类模式使用继承机制在类间分派行为。
行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务。
### Chain of responsibility(职责链)-对象行为型模式
#### 作用：
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
#### 适用性：
* 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定；
* 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；
* 可处理一个请求的对象集合应被动态指定。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%88%AA%E5%B1%8F2021-08-16%20%E4%B8%8B%E5%8D%889.35.59.png)
一个典型的对象结构可能如下图所示：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/E650B232-06A8-49DA-85FF-1479FCB97AE0.png)

### Command(命令)-对象行为型模式
#### 作用：
将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
#### 适用性：
* 抽象出待执行的动作以参数化某对象。可用回调表达这种参数化机制；
* 在不同的时刻指定、排列和执行请求；
* 支持取消操作；
* 支持修改日志，当系统崩溃时，这些修改可以被重做一遍；
* 用构建在原语操作上的高层操作构造一个系统。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/BF270E0C-064E-4631-B278-09300200D86F.png)
#### 相关模式：
Composite模式可被用来实现宏命令；
Memento模式可用来保持某个状态，命令用这一状态来取消它的效果；
在被放入历史表列前必须被拷贝的命令起到一种原型的作用。

### Interpreter(解释器)-类行为型模式
#### 作用：
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
#### 适用性：
当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。存在以下情况时该模式效果最好：
* 该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理；
* 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8D766044-B180-41BB-8F16-84CB98D84218.png)

### Iterator(迭代器)-对象行为型模式
#### 作用：
提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。
#### 适用性：
* 访问一个聚合对象的内容而无需暴露它的内部表示；
* 支持对聚合对象的多种遍历；
* 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7F9E325F-4718-4EC7-B11D-998A603CDB36.png)

### Mediator(中介者)-对象行为型模式
#### 作用：
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
#### 适用性：
* 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解；
* 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象；
* 想定制一个分布在多个类中的行为，而又不想生成太多的子类。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4DDCD362-DFD7-447F-80B9-F1638C8410EE.png)

### Memento(备忘录)-对象行为型模式
#### 作用：
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
#### 适用性：
* 必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态；
* 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/F7ECF040-7C0B-443C-8B96-71E98496D568.png)
#### 协作：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/E7A2969F-A583-424C-AF3E-2E2B10EA352A.png)

### Observer(观察者)-对象行为型模式
#### 作用：
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
#### 适用性：
* 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以个字独立地改变和复用；
* 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变；
* 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/95E0AEBD-0007-447C-8D5A-4A7E46302812.png)
#### 协作：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7B649636-5DC5-4A42-94E9-234174CAF3BC.png)

### State(状态)-对象行为型模式
#### 作用：
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
#### 适用性：
* 一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为；
* 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3F17A176-995A-4BF6-B20E-BA936F989EE8.png)

### Strategy(策略)-对象行为型模式
#### 作用：
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
#### 适用性：
* 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法；
* 需要使用一个算法的不同变体。当这些变体实现为一个算法的类层次时，可使用策略模式；
* 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构；
* 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/FBAACC58-4098-43A2-84BF-F268D5992132.png)

### Template Method(模版方法)-类行为型模式
#### 作用：
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
#### 适用性：
* 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；
* 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复（重分解以一般化）
* 控制子类扩展。模版方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/79F44A32-BD49-40C0-8DC3-D61DAF05BC41.png)

###  Visitor(访问者)-对象行为型模式
#### 作用：
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
#### 适用性：
* 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作；
* 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作；
* 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。
#### 结构：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/D5A24BDD-691E-4447-88FC-07CF099E3E15.png)
#### 协作：
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68ABD87A-D7AB-499F-97D7-B03D58FCDDCF.png)